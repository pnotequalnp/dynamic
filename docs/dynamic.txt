-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Dynamic Typing
--   
--   Dynamically typed data
@package dynamic
@version 0.2.0.0


module Dynamic

-- | Dynamically typed values. Values must be monomorphic. Attempting to
--   create a <a>Dynamic</a> from a polymorphic value will result an an
--   ambiguous type variable.
--   
--   <pre>
--   &gt;&gt;&gt; x = Dynamic (3 :: Int)
--   
--   &gt;&gt;&gt; :{
--   case x of
--     Dynamic (y :: String) -&gt; length y
--     Dynamic () -&gt; 0
--     Dynamic (x :: Int) -&gt; x * 2
--     _ -&gt; 42
--   :}
--   6
--   </pre>
data Dynamic :: Type
[MkDynamic] :: TypeRep a -> a -> Dynamic
pattern Dynamic :: forall a. Typeable a => a -> Dynamic

-- | Dynamically typed function application. The first argument must be a
--   function, and the second argument a compatible value, else a
--   <a>DynamicTypeError</a> will be thrown.
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   case ((+ 3) :: Int -&gt; Int) $@ (4 :: Int) of
--     Just (Dynamic (x :: Int)) -&gt; Just x
--     _ -&gt; Nothing
--   :}
--   Just 7
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; x = Dynamic (4 :: Int)
--   
--   &gt;&gt;&gt; f = Dynamic ((+ 3) :: Int -&gt; Int)
--   
--   &gt;&gt;&gt; :{
--   case f $@ x of
--     Just (Dynamic (x :: Int)) -&gt; Just x
--     _ -&gt; Nothing
--   :}
--   Just 7
--   </pre>
($@) :: (IsDynamic a, IsDynamic b, MonadThrow m) => a -> b -> m Dynamic
infixl 1 $@

-- | This operator is somewhat analogous to <a>&lt;*&gt;</a>. It is useful
--   for chaining function application.
--   
--   <pre>
--   &gt;&gt;&gt; x = Dynamic (4 :: Int)
--   
--   &gt;&gt;&gt; y = Dynamic (3 :: Int)
--   
--   &gt;&gt;&gt; f = Dynamic ((+) @Int)
--   
--   &gt;&gt;&gt; :{
--   case f $@ x *@ y of
--     Just (Dynamic (x :: Int)) -&gt; Just x
--     _ -&gt; Nothing
--   :}
--   Just 7
--   </pre>
(*@) :: (IsDynamic a, IsDynamic b, MonadThrow m) => m a -> b -> m Dynamic
infixl 1 *@

-- | Dynamic function composition.
--   
--   <pre>
--   &gt;&gt;&gt; f = Dynamic ((+ 3) :: Int -&gt; Int)
--   
--   &gt;&gt;&gt; g = Dynamic ((* 2) :: Int -&gt; Int)
--   
--   &gt;&gt;&gt; :{
--   case f .@ g *@ (4 :: Int) of
--     Just (Dynamic (x :: Int)) -&gt; Just x
--     _ -&gt; Nothing
--   :}
--   Just 11
--   </pre>
(.@) :: (IsDynamic a, IsDynamic b, MonadThrow m) => a -> b -> m Dynamic
infixr 8 .@

-- | Extract a dynamic value to a known concrete type.
--   
--   <pre>
--   &gt;&gt;&gt; x = Dynamic (4 :: Int)
--   
--   &gt;&gt;&gt; fromDynamic @Int @Maybe x
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromDynamic @String @Maybe x
--   Nothing
--   </pre>
fromDynamic :: forall a m. (MonadThrow m, Typeable a) => Dynamic -> m a

-- | Extract a dynamic value to a known concrete type with a default in
--   case of failure.
--   
--   <pre>
--   &gt;&gt;&gt; x = Dynamic (4 :: Int)
--   
--   &gt;&gt;&gt; fromDynamicOr "Hello" x
--   "Hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromDynamicOr (7 :: Int) x
--   4
--   </pre>
fromDynamicOr :: Typeable a => a -> Dynamic -> a

-- | Query the <a>TypeRep</a> of the dynamically typed value.
dynamicRep :: Dynamic -> SomeTypeRep

-- | A class to allow implicit demotion of statically typed values to
--   dynamically typed ones.
class IsDynamic a
toDynamic :: IsDynamic a => a -> Dynamic

-- | A runtime exception generated by dynamic typechecking.
data DynamicTypeError :: Type
[DynamicApplication] :: TypeRep a -> TypeRep b -> DynamicTypeError
[DynamicExtraction] :: TypeRep a -> TypeRep b -> DynamicTypeError
[DynamicComposition] :: TypeRep a -> TypeRep b -> DynamicTypeError
instance GHC.Show.Show Dynamic.DynamicTypeError
instance GHC.Exception.Type.Exception Dynamic.DynamicTypeError
instance Dynamic.IsDynamic Dynamic.Dynamic
instance Data.Typeable.Internal.Typeable a => Dynamic.IsDynamic a
instance GHC.Show.Show Dynamic.Dynamic
