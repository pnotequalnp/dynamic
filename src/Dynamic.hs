{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE ExplicitNamespaces #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GADTs #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE ViewPatterns #-}

-- |
-- Module      : Dynamic
-- Description : Dynamic Typing
-- Copyright   : Kevin Mullins 2022
-- License     : ISC
-- Maintainer  : kevin@pnotequalnp.com
module Dynamic (
  Dynamic (Dynamic, MkDynamic),
  ($@),
  (*@),
  (.@),
  fromDynamic,
  fromDynamicOr,
  dynamicRep,
  IsDynamic (..),
  DynamicTypeError (..),
) where

import Control.Monad.Catch (Exception, MonadThrow (..))
import Data.Kind (Type)
import Data.Maybe (fromMaybe)
import Type.Reflection (SomeTypeRep (SomeTypeRep), TypeRep, Typeable, eqTypeRep, typeRep, typeRepKind, pattern Fun, type (:~~:) (..))

-- $setup
-- >>> :set -XScopedTypeVariables
-- >>> :set -XTypeApplications

-- | Dynamically typed values. Values must be monomorphic. Attempting to create a `Dynamic` from a
-- polymorphic value will result an an ambiguous type variable.
--
-- >>> x = Dynamic (3 :: Int)
-- >>> :{
-- case x of
--   Dynamic (y :: String) -> length y
--   Dynamic () -> 0
--   Dynamic (x :: Int) -> x * 2
--   _ -> 42
-- :}
-- 6
data Dynamic :: Type where
  MkDynamic :: TypeRep a -> a -> Dynamic

pattern Dynamic :: forall a. Typeable a => a -> Dynamic
pattern Dynamic x <-
  (dynamic -> Just x)
  where
    Dynamic x = MkDynamic typeRep x

dynamic :: forall a. Typeable a => Dynamic -> Maybe a
dynamic (MkDynamic t x)
  | Just HRefl <- t `eqTypeRep` typeRep @a = Just x
  | otherwise = Nothing

instance Show Dynamic where
  showsPrec _ (MkDynamic t _) = showString "<<" . shows t . showString ">>"

-- | A class to allow implicit demotion of statically typed values to dynamically typed ones.
class IsDynamic a where
  toDynamic :: a -> Dynamic

instance IsDynamic Dynamic where
  toDynamic = id

instance {-# OVERLAPPABLE #-} Typeable a => IsDynamic a where
  toDynamic = Dynamic

-- | A runtime exception generated by dynamic typechecking.
data DynamicTypeError :: Type where
  DynamicApplication ::
    -- | The actual type of the function
    TypeRep a ->
    -- | The actual type of the argument
    TypeRep b ->
    DynamicTypeError
  DynamicExtraction ::
    -- | The actual type of the value
    TypeRep a ->
    -- | The type attempted to extract to
    TypeRep b ->
    DynamicTypeError
  DynamicComposition ::
    -- | The actual type of the left function
    TypeRep a ->
    -- | The actual type of the right function
    TypeRep b ->
    DynamicTypeError

deriving stock instance Show DynamicTypeError

instance Exception DynamicTypeError

-- | Dynamically typed function application. The first argument must be a function, and the second
-- argument a compatible value, else a `DynamicTypeError` will be thrown.
--
-- >>> :{
-- case ((+ 3) :: Int -> Int) $@ (4 :: Int) of
--   Just (Dynamic (x :: Int)) -> Just x
--   _ -> Nothing
-- :}
-- Just 7
--
-- >>> x = Dynamic (4 :: Int)
-- >>> f = Dynamic ((+ 3) :: Int -> Int)
-- >>> :{
-- case f $@ x of
--   Just (Dynamic (x :: Int)) -> Just x
--   _ -> Nothing
-- :}
-- Just 7
($@) ::
  (IsDynamic a, IsDynamic b, MonadThrow m) =>
  -- | A function of type @x -> y@
  a ->
  -- | A compatible value of type @x@
  b ->
  -- | The resulting value of type @y@
  m Dynamic
(toDynamic -> MkDynamic tf f) $@ (toDynamic -> MkDynamic tx x)
  | Fun a b <- tf
  , Just HRefl <- tx `eqTypeRep` a
  , Just HRefl <- typeRep @Type `eqTypeRep` typeRepKind b =
      pure (MkDynamic b (f x))
  | otherwise = throwM (DynamicApplication tf tx)

infixl 1 $@

-- | This operator is somewhat analogous to `<*>`. It is useful for chaining function application.
--
-- >>> x = Dynamic (4 :: Int)
-- >>> y = Dynamic (3 :: Int)
-- >>> f = Dynamic ((+) @Int)
-- >>> :{
-- case f $@ x *@ y of
--   Just (Dynamic (x :: Int)) -> Just x
--   _ -> Nothing
-- :}
-- Just 7
(*@) :: (IsDynamic a, IsDynamic b, MonadThrow m) => m a -> b -> m Dynamic
x *@ y = x >>= ($@ y)

infixl 1 *@

-- | Dynamic function composition.
--
-- >>> f = Dynamic ((+ 3) :: Int -> Int)
-- >>> g = Dynamic ((* 2) :: Int -> Int)
-- >>> :{
-- case f .@ g *@ (4 :: Int) of
--   Just (Dynamic (x :: Int)) -> Just x
--   _ -> Nothing
-- :}
-- Just 11
(.@) ::
  (IsDynamic a, IsDynamic b, MonadThrow m) =>
  -- | A function of type @y -> z@
  a ->
  -- | A function of type @x -> y@
  b ->
  -- | A function of type @x -> z@
  m Dynamic
(toDynamic -> MkDynamic tf f) .@ (toDynamic -> MkDynamic tg g)
  | Fun b' c <- tf
  , Fun a b <- tg
  , Just HRefl <- b `eqTypeRep` b'
  , Just HRefl <- typeRep @Type `eqTypeRep` typeRepKind a
  , Just HRefl <- typeRep @Type `eqTypeRep` typeRepKind b
  , Just HRefl <- typeRep @Type `eqTypeRep` typeRepKind c =
      pure (MkDynamic (Fun a c) (f . g))
  | otherwise = throwM (DynamicComposition tf tg)

infixr 8 .@

-- | Extract a dynamic value to a known concrete type.
--
-- >>> x = Dynamic (4 :: Int)
-- >>> fromDynamic @Int @Maybe x
-- Just 4
--
-- >>> fromDynamic @String @Maybe x
-- Nothing
fromDynamic :: forall a m. (MonadThrow m, Typeable a) => Dynamic -> m a
fromDynamic (MkDynamic t x)
  | Just HRefl <- t `eqTypeRep` typeRep @a = pure x
  | otherwise = throwM (DynamicExtraction t (typeRep @a))

-- | Extract a dynamic value to a known concrete type with a default in case of failure.
--
-- >>> x = Dynamic (4 :: Int)
-- >>> fromDynamicOr "Hello" x
-- "Hello"
--
-- >>> fromDynamicOr (7 :: Int) x
-- 4
fromDynamicOr :: Typeable a => a -> Dynamic -> a
fromDynamicOr x = fromMaybe x . fromDynamic

-- | Query the `TypeRep` of the dynamically typed value.
dynamicRep :: Dynamic -> SomeTypeRep
dynamicRep (MkDynamic t _) = SomeTypeRep t
